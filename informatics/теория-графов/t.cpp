#include <bits/stdc++.h>
#include <functional>
using namespace std;

/*
На отдыхе в Теплой Стране Вера познакомилась с симпатичным
волейболистом-трактористом Петром. Турист Петр, кстати,
собирается после отличного отдыха в Теплой Стране
отправиться в путешествие по городам Европы. Как известно,
Европа обладает развитой транспортной системой: в Европе
есть V интересующих Петра городов и E маршрутов ночных
поездов. Каждый маршрут соединяет два различных города,
время в пути составляет одну ночь. Поезда по маршруту
ходят в обоих направлениях.

Основной целью поездки Петра является осмотр местных
достопримечательностей. По- скольку Петр — невероятно
занятой человек, то он решил, что все путешествие должно
занимать не более четырех дней. Петр уже многое повидал,
поэтому на осмотр достопримечательностей в каждом городе
Петр тратит ровно один день. Он хочет составить наиболее
практичный тур: каждый день он будет тратить на осмотр
города, а каждую ночь — на переезд ночным поездом между
городами. Разумеется, Петр не имеет ни малейшего желания
посещать один город несколько раз.

Но на этом прагматичность Петра не заканчивается: Петр,
как настоящий турист, хочет посмотреть на самые красивые
европейские достопримечательности. Он долго изучал
справочники и для каждого города оценил свою ожидаемую
радость от его посещения p_i. Теперь он хочет найти
маршрут, при котором его радость будет наибольшей.
Помогите Петру найти такой маршрут.

Формат входного файла

В первой строке входных данных заданы два целых числа
V и E (1 ≤ V; E≤3∗10^5) — количество городов и маршрутов
поездов, соответственно. В следующей строке заданы V целых
чисел p_i (1 ≤ p_i ≤ 10^8), где p_i обозначает ожидаемую
радость от посещения го- рода с номером i. В следующих E
строках заданы описания маршрутов поездов. Каждое описание
состоит из пары различных чисел a_i и b_i (1 ≤ a_i; b_i ≤ V) -
номеров городов, между которыми курсирует этот маршрут
поезда. Гарантируется, что между каждой парой городов
существует не более одного маршрута поезда.

Формат выходного файла

В первой строке выходных данных выведите число K (1 ≤ K ≤ 4)
— количество городов в оптимальном маршруте туриста Петра.
В следующей строке выведите номера этих городов в порядке
посещения. Города нумеруются начиная с единицы. Если
оптимальных маршрутов несколько, выведите любой из них.

Система оценивания

Тесты к этой задаче состоят из пяти групп. Баллы за каждую
группу ставятся только при прохождении всех тестов группы
и всех тестов предыдущих групп.

0. Тесты 1–2. Тесты из условия, оцениваются в ноль баллов.

1. Тесты 3–16. В тестах этой группы V; E ≤ 100.
   Эта группа оценивается в 20 баллов

2. Тесты 17–32. В тестах этой группы V; E ≤ 1 000.
   Эта группа оценивается в 20 баллов.

3. Тесты 33–53. В тестах этой группы V ≤ 3 000, E ≤ 60 000.
   Эта группа оценивается в 30 баллов.

4. В тестах этой группы дополнительные ограничения отсутствуют.
   Эта группа оценивается в 30 баллов. Решение будет
   тестироваться на тестах этой группы oﬄine, т. е. после
   окончания тура.
*/

bool comp(const pair<int, int> &a, pair<int, int> &b)
{
    return (a.first > b.first);
}

int main(int argc, char const *argv[])
{
    // freopen("25", "r", stdin);
    // freopen("output.txt", "w", stdout);

    int V, E;
    cin >> V >> E;
    vector<vector<int>> g(V + 1);
    vector<int> p(V + 1);
    vector<pair<int, int>> e(E);

    for (int i = 1; i <= V; i++)
    {
        cin >> p[i];
    }

    for (int i = 0; i < E; i++)
    {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
        e[i] = make_pair(a, b);
    }

    // For every node find 3 neighbours with max p
    vector<vector<pair<int, int>>> variations(V + 1);
    for (int node = 1; node <= V; node++)
    {
        if (g[node].size() == 0)
            continue;
        int to_find = g[node].size() % 3;
        for (auto n : g[node])
            variations[node].push_back({p[n], n});
        nth_element(
            variations[node].begin(),
            variations[node].begin() + to_find,
            variations[node].end(),
            comp);
    }

    // Print out variations vector
    // for (auto v : variations)
    // {
    //     for (auto p : v)
    //         cout << p.first << '(' << p.second << ") ";
    //     cout << endl;
    // }

    pair<int, vector<int>> best_path(-1, vector<int>());

    // Маршрут состоит из 3 ребер, перебираем центральное ребро
    for (int i = 0; i < E; i++)
    {
        int b = e[i].first;
        int c = e[i].second;
        int a = -1, d = -1;
        // cout << "Проверяем вершину " << b << ": " << endl;
        for (auto n : variations[b])
        {
            // cout << n.second << "(" << n.first << ") ";
            if (n.second == c)
                continue;
            a = n.second;
            break;
        }
        for (auto n : variations[c])
        {
            if (n.second == b || n.second == a)
                continue;
            d = n.second;
            break;
        }

        // Новый маршрут
        vector<int> path;

        if (a != -1)
            path.push_back(a);
        path.push_back(b);
        path.push_back(c);
        if (d != -1)
            path.push_back(d);

        // Сумма весов всех вершин маршрута
        int s = accumulate(path.begin(), path.end(), 0, [&](int a, int b)
                           { return a + p[b]; });

        // Print out path
        // cout << s << ": ";
        // for (auto p : path)
        //     cout << p << ' ';
        // cout << endl;

        // Если новый маршрут лучше, то запоминаем его
        if (s > best_path.first)
            best_path = make_pair(s, path);
    }

    auto m = max_element(p.begin() + 1, p.end());
    // Может быть такое, что посещение одного города лучше чем посещение нескольких
    if (*m > best_path.first)
        best_path = make_pair(*m, vector<int>{(int)(m - p.begin())});

    if (best_path.first == -1)
    {
        cout << 0 << endl;
        return 0;
    }

    // cout << best_path.first << endl;
    cout << best_path.second.size() << endl;
    for (auto n : best_path.second)
        cout << n << " ";
    cout << endl;

    return 0;
}
